# dataIntegrationSampleSolutions.R
#
#   +-----------------------------------------------------------------+
#   |                                                                 |
#   |  Do not edit this file!                                         |
#   |                                                                 |
#   +-----------------------------------------------------------------+
#
# Purpose:  Sample solutions for the Data Model workshop unit.
#
# Version: 1.1
#
# Date:    2019  05  12
# Author:  Boris Steipe (boris.steipe@utoronto.ca)
#
# V 1.1    2019 Updates
# V 1.0    First code 2018
#
# TODO:
#   - Draft sketch for data objects that we need and that are integrated for
#     the final graph.
#   - gene models: GTF files?
#   - Work from non-intogen data (avoid having to go back to GRCh37).
#     Maybe include biomart package?
#   -
# ==============================================================================


#TOC> ==========================================================================
#TOC>
#TOC>   Section  Title                                     Line
#TOC> ---------------------------------------------------------
#TOC>   1        SCENARIO                                    39
#TOC>   2        READ DATA                                   43
#TOC>   3        EXPLORE DATA                               122
#TOC>   4        INTEGRATE  DATA                            216
#TOC>   4.1        BioMart provides integrated data         235
#TOC>   4.2        Put the data together                    274
#TOC>   5        PLOT THE DATA                              365
#TOC>
#TOC> ==========================================================================


# =    1  SCENARIO  ============================================================

# ...

# =    2  READ DATA  ===========================================================

# Task 2.1: Open coordinates 58,815,001 to 58,915,000 of the hg38 assembly
#           of chromosome 20 in the Ensembl genome browser. What gene is
#           annotated to this region?
#           - Google finds    https://useast.ensembl.org/index.html
#           - Simply enter "human 20:58815001-58915000" into the search field.

# Task 2.2: GNAS is a complex locus with multiple transcripts. Download the
#           transcript coordinates for protein coding genes. Hint: download
#           the data from the corresponding Ensembl gene page.
#           - click on any of the exons to open a pop-up - all exons lead to the
#             same gene: ENSG00000087460
#             https://useast.ensembl.org/Homo_sapiens/Gene/Summary?db=core;g=ENSG00000087460
#           - Click on "Export Data"
#           - Select "CSV (Comma Separated Values)" in the "Feature Fle" section
#           - Check ONLY the "Gene information" checkbox
#           - Click on "Next >"
#           - Choose output format: Text
#           - Save the result page as "ENSG00000087460data.csv"
#           - Read the file into an R data frame called GNAStranscripts.

GNAStranscripts <- read.csv("./data/ENSG00000087460data.csv",
                            header = TRUE,
                            as.is = TRUE)  # Don't convert strings into factors

head(GNAStranscripts)

# Task 2.3  Remove all rows from GNAStranscripts that are not protein coding.
#           - what column are we looking at?
#           "gene_type"
#
#           - what values exist in this column?
unique(GNAStranscripts$gene_type)

#           - how do we subset the data frame to the values we want?
sel <- which(GNAStranscripts$gene_type == "protein_coding")
GNAStranscripts <- GNAStranscripts[sel, ]

#           - how many transcripts do we have? What are their IDs?
(x <- unique(GNAStranscripts$transcript_id))

#           - restrict the rows to contain only Ensembl transcripts. How many
#             transcripts are left?
sel <- grep("^ENST", GNAStranscripts$transcript_id)
GNAStranscripts <- GNAStranscripts[sel, ]
(x <- unique(GNAStranscripts$transcript_id))

# Task 2.4  Calculate the transcript lengths for all transcripts. Store
#           them in a named vector called "tLengths".
#           - many ways to do this, here's one

# initialize a numeric vector, named with unique transcript ids
x <- unique(GNAStranscripts$transcript_id)
tLengths <- numeric(length(x))
names(tLengths) <- x

# iterate over all transcript ids, sum lengths
for (id in names(tLengths)) {
    sel <- which(GNAStranscripts$transcript_id == id)
    l <- 0
    for (idx in sel) {
        l <- l + (GNAStranscripts$end[idx] - GNAStranscripts$start[idx]) + 1
    }
    tLengths[id] <- l
}

plot(sort(tLengths, decreasing = TRUE))

# Task 2.5  Find the GNAS page on the IntOGen cancer driver gene website.
#             https://www.intogen.org/search?gene=GNAS
#           Explore the page. To download the mutation distribution, you need
#           to register (databases need records of who uses them to compete
#           for funding.) You can register and download, or use the file
#           "./data/GNAS-distribution-data.tsv" instead.
#
#           - Read the file into a data frame called "GNASmutations"
GNASmutations <- read.delim("./data/GNAS-distribution-data.tsv",
                            as.is = TRUE)

# =    3  EXPLORE DATA  ========================================================
#
# Task 3.1  View GNASmutations. What do you see?
#           - How many observations of each transcript?
(x <- sort(table(GNASmutations$TRANSCRIPT), decreasing = TRUE))
length(x)

#           - Are there transcripts that are not in our Ensembl table?
#               (hint: use the %in% operator)
#             %in% is one of the most important operators in data analysis,
#             I need it practically every day!
#             Here is a prototype example:
c("C", "A", "B") %in% c("E", "A", "D", "C", "G")  # TRUE TRUE FALSE
c("E", "A", "D", "C", "G") %in% c("C", "A", "B")  # FALSE TRUE FALSE TRUE FALSE
#             - The output is a boolean vector;
#             - it has the length of the first set;
#             - it is TRUE for every element of the first set that
#                 appears in the second set.
#             To count TRUE values, we can use the sum(<logical>) approach.
#             or we can use all() or any().
sum(GNASmutations$TRANSCRIPT %in% GNAStranscripts$transcript_id)
all(GNASmutations$TRANSCRIPT %in% GNAStranscripts$transcript_id)

#           - How many of each mutation type?
(x <- sort(table(GNASmutations$MOST_SEVERE), decreasing = TRUE))
length(x)

#           - Plot that!
pie(sort(table(GNASmutations$MOST_SEVERE), decreasing = TRUE))

#           - exclude the splice region variants, since their effect
#             is not predictable.
sel <- ! GNASmutations$MOST_SEVERE == "splice_region_variant"
GNASmutations <- GNASmutations[sel, ]

#           - Are the reference nucleotides correct for our GRCh38 data?
#           Step by step:
#             - extract a data frame of coordinates and reference alleles
myIntRef <- GNASmutations[ , c("START", "REF")]

#             - remove all rows that are not single nucleotides
myIntRef <- myIntRef[ (myIntRef$REF %in% c("A", "C", "G", "T")), ]  # or ...
myIntRef <- myIntRef[grep("[ACGT]", myIntRef$REF), ]

#             - look at it. Now remove all duplicates:
sel <- duplicated(myIntRef$START)
myIntRef <- myIntRef[! sel, ]

#             - calculate offset to mySeq position 1
#                 We downloaded from 20:58815001-58915000 - therefore a
#                 position i in myseq is i + 58815000 on chr20.
#
#             - look at the numbers. What's going on?
#
#             Apparently IntOGen uses GRCh37 coordinates!
#             Always confirm and test your data!!!
#
#             - How do we recover?
#             Easy: since everything is in a script, we simply re-run our script
#             on GRCh37 archive data!
#
#             - Let's first rename mySeq
mySeq38 <- mySeq
#
#             - next we find a gene source for GRCh37.
#               GRCh37 data are available in a stable archive at ensembl:
#               http://grch37.ensembl.org/index.html
#
#               Navigate to that page, select "human" in the search box and
#               enter GNAS.
#
#               ... find "GRCh37 full archive ..." on that page and click "Go".
#               To download the GRCh37 sequence (istead of our GRCh38
#               coordinates) ... the following URL will work:
# https://grch37.ensembl.org/Homo_sapiens/Export/Output/Location?db=core;output=fasta;r=20:57410001-57510000;genomic=unmasked;_format=Text
#
#             - save the output as chr20-100kbp.37.fasta
#             - then read it with
mySeq37 <- readFASTA("./data/chr20-100kbp.37.fasta")
#
#             - (verifications as before)
#
#             - calculate offset to mySeq position 1
#                 We downloaded from 20:57410001-57510000 - therefore a
#                 position i in myseq is i + 57410000 on chr20.
OFFSET <- 57410000
#
#             - Now we can extract our nucleotides ...
myGenomeRef <- data.frame(START = myIntRef$START,
                          REF = mySeq37[(myIntRef$START - OFFSET)],
                          stringsAsFactors = FALSE)
#               ... and compare:
all(myIntRef$REF == myGenomeRef$REF, na.rm = TRUE)
#             Very nice.


# =    4  INTEGRATE  DATA  =====================================================

# The resulting data is all over the place. We have a table with transcript
# annotations, a derived vector of lengths, some of our coordinates are
# from GRCh37, some are GRCh38. Integrating this might be messy ...
# we'll explore BioMart, a versatile integration solution.
#
#
# Now: what do we need to integrate for our plot?
# - we need genomic coordinates, because that's what our sequencing
#   experiments and variant calling return;
# - we need the coding sequence
# - we need the codon positions/translation
# - we need the mutations that are mapped to the sequence of interest
#
# ==   4.1  BioMart provides integrated data  ==================================
#
# Navigate to http://www.ensembl.org/. Click on BioMart. Getting data
# from BioMart involves four steps:
# - Choose the Database: here - choose Ensembl Genes 92
# - Choose the Dataset:  here - choose Human Genes (GRCh38 p.13)
# - Choose Filters:      explore what's available. The Gene ID for GNAS is
#                          ENSG00000087460. Set this as the filter.
#
# - Choose Attributes:   explore what's available. Most importantly, we need a
#                        gene model. (Actually I haven't found a downloadable
#                        gene model for human genes anywhere else. Or do you
#                        know of a source?) How do we get a gene model from
#                        BioMart?
#  >>> - select Structures
#  >>> - in Gene, choose:
#          - Gene stable ID
#          - Transcript stable ID
#      - in Exon, choose:
#          - Exon rank in transcript
#          - Genomic coding start
#          - Genomic coding end
#          - Exon stable ID
#
# Once you have selected what you need  - or just to explore what you selected,
# as a preview - click "Results". Finally select ...
# "Export all results to" ... "File" "TSV" , and "Go". Inspect the resulting
# file. But hold on ... are these the coordinates we need? No: we need this for
# GRCh37. Rather than repeat everything, just work with the (supplied) correct
# gene model coordinates in the "sampleSolutions" folder.
#
#      >>>    c.f. ./sampleSolutions/GNASgeneModels.37.tsv
#
#             - Read the data into a data frame, call it GNASmodels

GNASmodels <- read.delim("./sampleSolutions/GNASgeneModels.37.tsv",
                         as.is = FALSE)

# ==   4.2  Put the data together  =============================================
#
# Task 4.2.1 Create a data frame for a GNAS-2 gene model according to the
#            following specifications:
#
#     -  Choose data for  ENST00000371095 (codes for ENSP00000360136 / NP_536351
#          / GNASS / GNAS-2 / isoform of P36092)
#     -  call the data frame GNAS2model and store columns "start" and "end" for
#        each CDS segment

sel <- grep("ENST00000371095", GNASmodels$Transcript.stable.ID)
GNAS2Model <- data.frame(start = GNASmodels$Genomic.coding.start[sel],
                         end   = GNASmodels$Genomic.coding.end[sel])

#     -  Make sure the segments are in the correct order.
GNAS2Model

# >>>> Hey!
GNASmodels$Exon.rank.in.transcript[sel]

# >>> ... can't be too careful! We need to fix the order.
GNAS2Model <- GNAS2Model[order(GNAS2Model$start), ]

# Task 4.2.2 Create a data frame for GNAS-2 protein annotations, according to
#            the  following specifications:
#
#     -  Call it GNAS2protein
#     -  It should have one row for each nucleotide in the CDS
#     -  Give it the following columns:
#           GNAS2protein$coord     - the genomic coordinates
#           GNAS2protein$nuc       - the actual nucleotide
#           GNAS2protein$codonPos  - 1,2 or 3: the codon position
#           GNAS2protein$aa        - The amino acid (in codon position 1 only)
#           GNAS2protein$iCodon    - The codon index (in all three positions)


coord2vec <- function(m) {
    v <- numeric()
    for (i in 1:nrow(m)) {
        v <- c(v, m$start[i]:m$end[i])
    }
    return(v)
}

GNAS2protein <- data.frame(coords = coord2vec(GNAS2Model))
GNAS2protein$nuc <- mySeq37[GNAS2protein$coords - OFFSET]
GNAS2protein$codonPos <- 1:3

if (! requireNamespace("seqinr")) {
    install.packages("seqinr")
}
x <- seqinr::translate(GNAS2protein$nuc)

tail(GNAS2protein) # looking good
paste(x, collapse = "")  # is this correct?

GNAS2protein$aa <- " "
sel <- which(GNAS2protein$codonPos == 1)
GNAS2protein$aa[sel]     <- translate(GNAS2protein$nuc)

GNAS2protein$iCodon <- floor((0:(nrow(GNAS2protein) - 1)) / 3) + 1


# Task 4.2.2 Create a data frame for GNAS-2 protein mutations, according to
#            the  following specifications:
#     -  Call it GNAS2mut
#     -  Get all rows from GNASmutations where the positions fall
#          into the GNAS-2 CDS

sel <- which(GNASmutations$START %in% GNAS2protein$coords)
GNAS2mut <- GNASmutations[sel, ] # Note: technically, not all of these have been
                                 # observed on the GNAS2 transcript, allthough
                                 # they all fall into the GNAS2 CDS

# >>> confirm that the reference nucleotides are the nucleotides we have
#     in GNAS2protein
idx <- grep("[ACGT]", GNAS2mut$REF)
for (i in idx) {
    cat(sprintf("%d - %s - %s\n",
                GNAS2mut$START[i],
                GNAS2mut$REF[i],
                GNAS2protein$nuc[GNAS2protein$coords == GNAS2mut$START[i]]))
}

table(GNAS2mut$START)  # how many of each?


# =    5  PLOT THE DATA  =======================================================
#
# Time for a Lolliplot

# Task 5.1 What categories of effects do we have?
unique(GNAS2mut$MOST_SEVERE)

# Task 5.2 Define colors for the categories - (Hint: pick a palette e.g. with
#          https://color.adobe.com/ You are looking for a divergent spectrum
#          that emphasizes similar vs. different effects.
#
#          e.g. "#D42823AA"      # "frameshift_variant"
#               "#FC7B14AA"      # "missense_variant"
#               "#ED69A7AA"      # "stop_gained"
#               "#CAD1FAAA"      # "synonymous_variant"
#
#          - also define a color for a rectangle that symbolizes the
#            protein:
colProtein <- "#82A2D1"

#          - to work with the effect categories, put them into a
#            data frame: eff$effects - the effects
#                        eff$cols    - the colours
#                        eff$heights - the vertical positions
#          - give the data frame rownames of the effects, so it's easy
#            to fetch data by rowname

eff <- data.frame( effects = sort(unique(GNAS2mut$MOST_SEVERE)),
                   cols = c("#D42823A3",   # "frameshift_variant"
                            "#FC7B14A3",   # "missense_variant"
                            "#ED69A7A3",   # "stop_gained"
                            "#CAD1FAA3"),  # "synonymous_variant"
                   heights = c(1.7, 3.0, 2.3, 1.0),
                   stringsAsFactors = FALSE)
rownames(eff) <- eff$effect

#  >>> let's verify our colors: looking good?
barplot(rep(10, 4),
        axes = FALSE,
        names.arg = eff$effects,
        las = 2,
        cex.names = 0.5,
        col = eff$cols)


# Task 5.3 Compile the mutations by amino acid and mutation type.
#          - define a matrix with rows for each mutated position,
#            columns for each effect category. Give it rownames() of
#            positions, colnames() of effects - so we can easily
#            access data by position and mutation type. Call the matrix
#            mMut

sel <- which(GNAS2protein$coords %in% GNAS2mut$START)
positions <- unique(GNAS2protein$iCodon[sel])
mMut <- matrix(numeric(length(positions) * nrow(eff)), ncol = nrow(eff))
rownames(mMut) <- positions
colnames(mMut) <- eff$effects

#          - iterate over all mutations, find which sequence position it
#            affects with which effect, and increment the value you find
#            in the mMut matrix.

for (i in 1:nrow(GNAS2mut)) {
    sel <- which( GNAS2protein$coords  %in% GNAS2mut$START[i])
    pos <- as.character(GNAS2protein$iCodon[sel])
    e <- GNAS2mut$MOST_SEVERE[i]
    mMut[pos, e] <- mMut[pos, e] + 1
}

# Task 5.4 Prepare for plotting.
#          - How do we draw circles on the plot?

# >>> We could use the draw.circle() function in the
# plotrix package - but that won't work if we don't take care to set the aspect
# ratio of the plot to 1. Better to use plotting symbols and vary their size.
# The symbol we need is number 21:
plot(1:4,
     rep(1,4),
     pch = 21,
     xlim = c(0, 5),
     axes = FALSE, xlab = "", ylab = "",
     cex = seq(1, 8, length.out = 4),
     col = "#555555",
     bg = eff$cols)


#          - What size should the circles have?
# >>> write a function to calculate plot symbol sizes
n2cex <- function(n, nMax) {
    cMax <- 5
    return((n / nMax) * cMax)
}

#          - How do we put graphic elements on a plot in principle?
#          (Hint: draw an empty plot of the correct size, then add
#                 lines(), points(), rectangle(), polygon() or text().
#                 Also add axes(). And a legend. And a title.)



# Task 5.4 Define a layout - x, and y ddimensions
# >>> x- axis from 0 to sequence length + 1
#     y axis from 0 to 5, centering the four circle categories on 1 to 4
#
# Task 5.5. Plot ...
#           - an empty frame to setup the coordinates...
plot(0, 0,
     type = "n",
     xlim = c(0, ceiling(max(GNAS2protein$iCodon) / 100) * 100),
     ylim = c(0, nrow(eff) + 2),
     xlab = "GNAS-2 sequence position",
     ylab = "",
     main = "CDS mutations by effect and frequency",
     axes = FALSE)

#            - draw a rectangle for the protein ...
rect(xleft = 1,
     ybottom = 0,
     xright = max(GNAS2protein$iCodon),
     ytop = 0.15,
     col = colProtein)

#           - and an axis at the bottom ...
axis(side = 1)


#            -  then plot the mutations for all positions and categories ...
nMax <- max(mMut)

for (i in 1:nrow(mMut)) {
    for (j in 1:ncol(mMut)) {
        if ((n <- mMut[i, j]) > 0) {
            x <- as.numeric(rownames(mMut)[i])
            y <- eff[colnames(mMut)[j], "heights"]
            thisCol <- eff[colnames(mMut)[j], "cols"]
            # draw a line
            lines(c(x, x), c(0.15, y), col = "#00000033")
            # draw the circle
            points(x, y, pch = 21, cex = n2cex(n, nMax), bg = thisCol)
        }
    }
}

#            - finally, plot a legend
# >>> order it correctly
ord <- order(eff$heights, decreasing = TRUE)
legend("topright",
       eff$effects[ord],
       cex = 0.9,
       fill = eff$cols[ord],
       bty = 'n',
       border = "#000000")

# Done.

# [END]
