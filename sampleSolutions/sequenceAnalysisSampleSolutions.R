# sequenceAnalysisSampleSolutions.R
#
#   +-----------------------------------------------------------------+
#   |                                                                 |
#   |  Do not edit this file!                                         |
#   |                                                                 |
#   +-----------------------------------------------------------------+
#
# Purpose:  Sample solutions for Sequence Analysis workshop unit.
#
# Version: 1.1
#
# Date:    2019  05  12
# Author:  Boris Steipe (boris.steipe@utoronto.ca)
#
# V 1.1    2019 updates
# V 1.0    First code 2018
#
# TODO:
#
# ==============================================================================


#TOC> ==========================================================================
#TOC> 
#TOC>   Section  Title                     Line
#TOC> -----------------------------------------
#TOC>   1        READ DATA                   36
#TOC>   2        ANALYZE THE DATA           123
#TOC>   3        PLOT DATA                  214
#TOC> 
#TOC> ==========================================================================


#===============================================================================
# =    1  READ DATA  ===========================================================
#===============================================================================

# We will consider 100,000 nucleotides from human chromosome 20. What are the
# dinucleotide frequencies? Are they random?

# Task 2.1: Find a source for nucleotides 58,815,001 to 58,915,000 on the
#           hg38 assembly of chromosome 20.
#
#             Ensembl has the data -
#               - navigate to https://useast.ensembl.org/Homo_sapiens/Info/Index
#               - paste into the "Search Human" field: 20:58815001-58915000
#               - click GO
#               - study the browser page
#               - click "Export Data"
#               - confirm coordinates, output "FASTA Sequence",
#                   genomic unmasked. Then click "Next
#               - follow the "Text" format link
#               - save data into your project folder as "chr20-100kbp.fasta"
#
#
#
#          What format is this in?
#            - FASTA format
#
#          NOTE that the URL is structured in a way that you can get this data
#          programmatically from the Web.
#
#          https://useast.ensembl.org/Homo_sapiens/Export/Output/Location?db=core;flank3_display=0;flank5_display=0;output=fasta;r=20:58815001-58915000;strand=feature;exon=yes;genomic=unmasked;utr3=yes;utr5=yes;coding=yes;intron=yes;cdna=yes;peptide=yes;_format=Text
#          ... or minimally
#
#          https://useast.ensembl.org/Homo_sapiens/Export/Output/Location?db=core;output=fasta;r=20:58815001-58915000;genomic=unmasked;_format=Text
#
#         How is this format specified?
#           - It's a bit of a mess - see: https://en.wikipedia.org/wiki/FASTA_format
#           - In principle: - one or more sequences per file;
#                           - separated by a single header line which
#                             starts with ">";
#                           - containing DNA or amino acid sequence in
#                             one-letter code, and possibly gap characters;
#                           - and possibly terminated with a "*".
#
# Task 2.2: Prepare to read the data into R.
#           - How do we read this in?
#             - use readLines(), then parse the contents.
#             - But there are alternatives:
#                 - the seqinr package has a read.fasta() function
#                 - bioconductor has readDNAStringSet()
#
#             - How do we keep the data in memory?
#                 - that depends on what we want to do with it: for some tasks
#                      it's better to use single strings - e.g. if we want to
#                      apply regular expression searches. For other tasks, its
#                      better to use a vector of single characters. But strings
#                      and single-character-vectors are easily interconverted.
#                      (e.g. seqinr has s2c() and c2s() )
#
#             Write a function that takes a filename as an argument and
#             returns the sequence as a vector with one character per element.
#
#
# Task 2.3: Test and verify that your function is correct.
#           - What should you test for?
#             - Follow the following principle:
#                 - verify that the function performs according to
#                   specification with valid input, and
#                 - that the function does not give misleading output with
#                   invalid input.
#           - How should you test?
#             - Use the testthat package.
#             - Either: put tests directly into your function source, and
#                 run the tests every time you update the code. Also, every
#                 time you fix a bug, write a test that would have discovered
#                 the bug. (Regression tests)
#             - Or: put tests into a separate directory, and test your whole
#                 project automatically (cf. testthat documentation).
#             - Intro to testthat principles in unitTesting.R
#
# Task 2.4: Actually read "chr20-100kbp.fasta" and assign it to "mySeq".
              mySeq <- readFasta("./data/chr20-100kbp.fasta")
#           - confirm that this has worked. How?
              objectInfo(mySeq)
              length(mySeq)
              head(mySeq)
              tail(mySeq)
#             ... and compare with input

# =    2  ANALYZE THE DATA  ====================================================
#
# Task 3.1: Calculate the GC contents
#           - how?
#             - a for-loop with counters ...
nA <- 0
nC <- 0
nG <- 0
nT <- 0
for (i in 1:length(mySeq)) {
    if (mySeq[i] == "A") { nA <- nA + 1 }
    if (mySeq[i] == "C") { nC <- nC + 1 }
    if (mySeq[i] == "G") { nG <- nG + 1 }
    if (mySeq[i] == "T") { nT <- nT + 1 }
}

(nG + nC) / (nA + nC + nG + nT)

#             - using grepl() ...
sum(grepl("[GC]", mySeq)) / length(mySeq)

#             - using table() ...
(tab <- table(mySeq))
(tab["G"] + tab["C"]) / sum(tab)

# Task 3.2: Is this value expected? What is the human average?
#           - Find the value.
#             - around 40%
#             - would we consider this different?
t.test(as.integer(grepl("[GC]", mySeq)), mu = 0.4) # one sample t-Test
#           - Is it constant throughout the genome?
#             No - isochores!
#             - so what's the distribution here?
#                Plot it ...

block <- 300
x <- numeric(floor(length(mySeq) / block))
pos <- seq(1, length(mySeq), by = block)
for (i in seq_along(pos)) {
    x[i] <- sum(grepl("[GC]", mySeq[pos[i]:(pos[i] + (block - 1))])) / block
}
plot(x)
abline(h = sum(grepl("[GC]", mySeq)) / length(mySeq), col = "#AA0000")



# Task 3.3: What are the dinucleotide distributions?
#           - Make a vector of dinucleotides (hint: use paste() )

ch20DiNuc <- paste(mySeq[1:99999], mySeq[2:100000], sep = "")
head(ch20DiNuc)
tail(ch20DiNuc)

#           - Get the counts (hint: use table() )
(ch20DiNucTable <- table(ch20DiNuc))
# save(ch20DiNucTable, file ="./sampleSolutions/ch20DiNucTable.RData")

barplot(ch20DiNucTable)



# Task 3.4: What are the expected dinucleotide frequencies?
#           - Can we get them from first principles?
#             From first principles, we expect that the frequency of a
#             dinucleotide is the 1/2 the product of the frequencies of the
#             nucleotides. Let's assemble them in a loop. We want the output
#             to be a named vector of frequencies.

(tab <- table(mySeq))
fTab <- tab / sum(tab)
fRandDiNuc <- numeric(length(fTab)^2)
for (i in seq_along(fTab)) {
    for (j in seq_along(fTab)) {
        idx <- ((i - 1) * 4) + j
        fRandDiNuc[idx] <- fTab[i] * fTab[j]
        names(fRandDiNuc)[idx] <- paste(names(fTab)[i], names(fTab)[j], sep = "")
    }
}
fRandDiNuc

#           - Can we simulate them (hint: use sample())

#              - A: sample with target frequencies
x1 <- sample(c("A", "C", "G", "T"), 100000, replace = TRUE, prob = fTab)
table(x1)

#              - B: shuffle mySeq
x2 <- sample(mySeq)
table(x2)


# =    3  PLOT DATA  ===========================================================


# Task 4.1: Plot observed and expected frequencies as a barplot() .
#           - Plain barplot
barplot(ch20DiNucTable)

#           - Frequencies, not counts
barplot(ch20DiNucTable/sum(ch20DiNucTable))

#           - add a title
barplot(ch20DiNucTable/sum(ch20DiNucTable),
        main = "Dinucleotides: chr20:58815001-58915000",
        ylab = "frequency")

#           - reduce the x-axis font
barplot(ch20DiNucTable/sum(ch20DiNucTable),
        main = "Dinucleotides: chr20:58815001-58915000",
        ylab = "frequency",
        cex.names = 0.5)


#           - sort
barplot(sort(ch20DiNucTable/sum(ch20DiNucTable), decreasing = TRUE),
        main = "Dinucleotides: chr20:58815001-58915000",
        ylab = "frequency",
        cex.names = 0.5)

#           - add color (discuss hex)
barplot(sort(ch20DiNucTable/sum(ch20DiNucTable), decreasing = TRUE),
        main = "Dinucleotides: chr20:58815001-58915000",
        ylab = "frequency",
        cex.names = 0.5,
        col = "#0070AA")

#           - add expected values as overlay (confirm that the order is correct
#             discuss sort() and order() - fTab, sort(fTab), order(fTab) )
barplot(sort(ch20DiNucTable/sum(ch20DiNucTable), decreasing = TRUE),
        main = "Dinucleotides: chr20:58815001-58915000",
        ylab = "frequency",
        cex.names = 0.5,
        col = "#0070AA")
barplot(fRandDiNuc[order(ch20DiNucTable/sum(ch20DiNucTable),
                         decreasing = TRUE)],
        col = "#DD0055",
        axisnames = FALSE,
        add = TRUE)

#           - add transparency (discuss Alpha)
barplot(sort(ch20DiNucTable/sum(ch20DiNucTable), decreasing = TRUE),
        main = "Dinucleotides: chr20:58815001-58915000",
        ylab = "frequency",
        cex.names = 0.5,
        col = "#0070CC7F")
barplot(fRandDiNuc[order(ch20DiNucTable/sum(ch20DiNucTable),
                         decreasing = TRUE)],
        col = "#DD005555",
        axisnames = FALSE,
        add = TRUE)
#           - add a line for the expected value
abline(h = 1/16, col = "#5555CC33")

#           - add a legend
legend("topright",
       c("Observed", "Expected"),
       cex = 0.8,
       fill = c("#0070CC7F", "#DD005555"), bty = 'n',
       border = "#000000")

#



# [END]
